(this["webpackJsonpthree-template"]=this["webpackJsonpthree-template"]||[]).push([[0],{31:function(e,n,t){},49:function(e,n,t){"use strict";t.r(n);var i=t(6),s=t(9),o=t(14),r=t.n(o),a=t(10),c=t(22),l=t(24),v=t(0),d=t(4),h=t(2),m=t(3),u=t(20),x=t.n(u),p=function(e){Object(h.a)(t,e);var n=Object(m.a)(t);function t(e){var i;return Object(v.a)(this,t),(i=n.call(this,e)).state={active:!0},i}return Object(d.a)(t,[{key:"render",value:function(){var e=this,n=this.state.active,t=this.props,s=t.once,o=t.children,r=Object(l.a)(t,["once","children"]);return Object(i.jsx)(x.a,Object(a.a)(Object(a.a)({active:n,onChange:function(n){s&&n&&e.setState({active:!1},(function(){return console.log("turned the things off")}))}},r),{},{children:function(e){var n=e.isVisible;return o({isVisible:n})}}))}}]),t}(s.Component),f=t.p+"static/media/img4.a5bf396c.jpg",y=t.p+"static/media/img3.1d24b7c4.jpg",b=t(1),g=t(23),j=t(21),w=t(25),z=t(13),O=function(e){Object(h.a)(t,e);var n=Object(m.a)(t);function t(e){var i;return Object(v.a)(this,t),(i=n.call(this,e)).stop=function(){i.setState({paused:!0})},i.play=function(){i.setState({paused:!1})},i.setupResize=function(){i.mount.addEventListener("resize",i.resize)},i.handleUpdate=function(e){return i.setState((function(n){return{data:Object(a.a)(Object(a.a)({},n.data),e)}}))},i.state={time:0,paused:!0,isRunning:!1,data:{distortion:0,bloomStrength:0}},i}return Object(d.a)(t,[{key:"componentDidMount",value:function(){var e=this;this.renderer=new b.u,this.renderer.setSize(window.innerWidth,window.innerHeight),this.container=this.mount,this.camera=new b.i(70,window.innerWidth/window.innerHeight,.001,5e3),this.camera.position.set(0,0,1e3),this.scene=new b.m,this.renderer.setClearColor(0,1),this.renderer.setPixelRatio(window.devicePixelRatio),this.width=this.mount.clientWidth,this.height=this.mount.clientHeight,this.mount.appendChild(this.renderer.domElement),this.addPost(),this.addMesh(),this.settings(),this.resize(),this.init(),this.mount.addEventListener("click",(function(){z.a.to(e.material.uniforms.distortion,{duration:2,value:2,ease:"power2.inOut"}),z.a.to(e.material.uniforms.progress,{duration:.5,value:1,delay:1.5}),z.a.to(e.bloomPass,{duration:2,strength:6,ease:"power2.in"}),z.a.to(e.material.uniforms.distortion,{duration:2,value:0,delay:2,ease:"power2.inOut"}),z.a.to(e.bloomPass,{duration:2,strength:0,delay:2,ease:"power2.out"})}))}},{key:"settings",value:function(){this.settings={progress:0,distortion:0}}},{key:"addPost",value:function(){this.renderScene=new j.a(this.scene,this.camera),this.bloomPass=new w.a(new b.q(window.innerWidth,window.innerHeight),1.5,.4,.85),this.bloomPass.threshold=this.state.data.bloomThreshold,this.bloomPass.strength=this.state.data.bloomStrength,this.bloomPass.radius=this.state.data.bloomRadius,this.composer=new g.a(this.renderer),this.composer.addPass(this.renderScene),this.composer.addPass(this.bloomPass)}},{key:"addMesh",value:function(){this.material=new b.n({fragmentShader:"\n\nuniform float time;\nuniform float progress;\nuniform sampler2D t; \nuniform sampler2D t1; \nuniform vec4 resolution;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nfloat PI = 3.141592653589793238;\n\nvoid main()\t{\n    \n    vec4 tt = texture2D(t,vUv);\n    vec4 tt1 = texture2D(t1,vUv);\n\n    vec4 finalTexture = mix(tt, tt1, progress);\n\n    gl_FragColor = finalTexture;\n\n    if(gl_FragColor.r < 0.1 && gl_FragColor.b<0.1 && gl_FragColor.g<0.1) discard;\n    \n    //gl_FragColor = vec4(1.,0.,0.,0.5);\n\n}\n",vertexShader:"\n\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform sampler2D t; \nuniform float distortion;\n\nfloat PI = 3.141592653589793238;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n      i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n\n}\n\n\n// via: https://petewerner.blogspot.jp/2015/02/intro-to-curl-noise.html\nvec3 curlNoise( vec3 p ){\n\n  const float e = 0.1;\n\n  float  n1 = snoise(vec3(p.x, p.y + e, p.z));\n  float  n2 = snoise(vec3(p.x, p.y - e, p.z));\n  float  n3 = snoise(vec3(p.x, p.y, p.z + e));\n  float  n4 = snoise(vec3(p.x, p.y, p.z - e));\n  float  n5 = snoise(vec3(p.x + e, p.y, p.z));\n  float  n6 = snoise(vec3(p.x - e, p.y, p.z));\n\n  float x = n2 - n1 - n4 + n3;\n  float y = n4 - n3 - n6 + n5;\n  float z = n6 - n5 - n2 + n1;\n\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\nvoid main()\t{\n    vUv = uv;\n    vec3 distortion1 = vec3(position.x*2., position.y, 1.) * curlNoise(vec3(\n      position.x*0.002 + time*0.1,\n      position.y*0.008 + time*0.1,\n      (position.x + position.y)*0.02 ))*distortion;\n    vec3 finalPosition = position + distortion1;\n    vec4 mvPosition = modelViewMatrix * vec4( finalPosition, 1.);\n    gl_PointSize = 2.; \n    gl_Position = projectionMatrix * mvPosition;\n\n}\n",extensions:{derivatives:"#extension GL_OES_standard_derivatives: enable"},uniforms:{time:{type:"f",value:0},distortion:{type:"f",value:0},t:{type:"t",value:(new b.o).load(f)},t1:{type:"t",value:(new b.o).load(y)},resolution:{type:"v4",value:new b.s},progress:{type:"f",value:0},uvRate1:{value:new b.q(1,1)}},side:b.d}),this.geometry=new b.j(1920,1280,960,640),this.plane=new b.k(this.geometry,this.material),this.scene.add(this.plane)}},{key:"resize",value:function(){var e=this.mount.clientWidth,n=this.mount.clientHeight;this.renderer.setSize(e,n),this.camera.aspect=e/n,this.composer.setSize(e,n),this.camera.updateProjectionMatrix()}},{key:"init",value:function(){var e=this.state.time;e+=.05,this.setState({time:e}),this.material.uniforms.time.value=this.state.time,this.requestID=requestAnimationFrame(this.init.bind(this)),this.composer.render()}},{key:"componentWillUnmount",value:function(){this.stop(),this.scene=null,this.camera=null,cancelAnimationFrame(this.requestID),this.mount.removeChild(this.renderer.domElement)}},{key:"render",value:function(){var e=this;return Object(i.jsx)(i.Fragment,{children:Object(i.jsx)("div",{id:"container",ref:function(n){return e.mount=n}})})}}]),t}(s.Component);t(31);function _(){return Object(i.jsxs)(i.Fragment,{children:[Object(i.jsxs)("div",{className:"frame",children:[Object(i.jsx)("h1",{className:"frame__title",children:"Webgl React Click"}),Object(i.jsx)("div",{className:"frame__links"}),Object(i.jsxs)("div",{className:"frame__nav",children:[Object(i.jsx)("a",{className:"frame__link",href:"https://isengupt.github.io/shaders/",children:"Previous"}),Object(i.jsx)("a",{className:"frame__link",href:"#",children:"Resume"}),Object(i.jsx)("a",{className:"frame__link",href:"https://github.com/isengupt/webgl-click/",children:"GitHub"})]})]}),Object(i.jsxs)("div",{className:"main__item",children:[Object(i.jsx)("div",{className:"text__container",children:Object(i.jsx)(p,{partialVisibility:!0,children:function(e){var n=e.isVisible;return Object(i.jsx)(i.Fragment,{children:Object(i.jsx)(c.Spring,{delay:150,to:{transform:n?"translateY(0px) rotate(0deg)":"translateY(300px) rotate(20deg)"},children:function(e){return Object(i.jsx)("h3",{className:"moving__text",style:Object(a.a)({},e),children:"Suspendisse"})}})})}})}),Object(i.jsx)(O,{})]})]})}r.a.render(Object(i.jsx)(_,{}),document.getElementById("root"))}},[[49,1,2]]]);
//# sourceMappingURL=main.671aa864.chunk.js.map