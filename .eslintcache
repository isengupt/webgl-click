[{"/Users/ishansengupta/Desktop/icosohedron/src/index.js":"1","/Users/ishansengupta/Desktop/icosohedron/src/App.js":"2","/Users/ishansengupta/Desktop/icosohedron/src/shaders/fragment.js":"3","/Users/ishansengupta/Desktop/icosohedron/src/shaders/vertex.js":"4","/Users/ishansengupta/Desktop/icosohedron/src/Backdrop.js":"5","/Users/ishansengupta/Desktop/icosohedron/src/components/VisibilitySensor.js":"6"},{"size":159,"mtime":1608340881208,"results":"7","hashOfConfig":"8"},{"size":1640,"mtime":1608343502533,"results":"9","hashOfConfig":"8"},{"size":518,"mtime":1608315533193,"results":"10","hashOfConfig":"8"},{"size":3992,"mtime":1608310570225,"results":"11","hashOfConfig":"8"},{"size":6318,"mtime":1608342878588,"results":"12","hashOfConfig":"8"},{"size":738,"mtime":1608340124149,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"10ghmgm",{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"23"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"16"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/Users/ishansengupta/Desktop/icosohedron/src/index.js",[],["29","30"],"/Users/ishansengupta/Desktop/icosohedron/src/App.js",["31"],"/Users/ishansengupta/Desktop/icosohedron/src/shaders/fragment.js",[],"/Users/ishansengupta/Desktop/icosohedron/src/shaders/vertex.js",[],["32","33"],"/Users/ishansengupta/Desktop/icosohedron/src/Backdrop.js",["34"],"import React, { Component } from \"react\";\n\nimport { fragment } from \"./shaders/fragment\";\nimport { vertex } from \"./shaders/vertex\";\n\nimport t from \"./img/img4.jpg\";\nimport t1 from \"./img/img3.jpg\";\n\nimport * as THREE from \"three\";\n//import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\nimport { UnrealBloomPass } from \"three/examples/jsm/postprocessing/UnrealBloomPass\";\nimport { gsap } from \"gsap\";\n\nclass Backdrop extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      time: 0,\n      paused: true,\n      isRunning: false,\n\n      data: {\n        distortion: 0.0,\n        bloomStrength: 0.0,\n      },\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    \n\n  }\n\n  componentDidMount() {\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.container = this.mount;\n\n    this.camera = new THREE.PerspectiveCamera(\n      70,\n      window.innerWidth / window.innerHeight,\n      0.001,\n      5000\n    );\n\n    this.camera.position.set(0, 0, 1000);\n    this.scene = new THREE.Scene();\n    //this.textures = [new THREE.TextureLoader().load(t)];\n    //this.renderer.physicallyCorrectLights = true;\n    this.renderer.setClearColor(0x000000, 1);\n    //this.renderer.outputEncoding = THREE.sRGBEncoding;\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n\n    this.width = this.mount.clientWidth;\n    this.height = this.mount.clientHeight;\n    this.mount.appendChild(this.renderer.domElement);\n    //this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n\n    this.addPost();\n    this.addMesh();\n    this.settings();\n    this.resize();\n\n    this.init();\n\n    this.mount.addEventListener(\"click\", () => {\n      /*    gsap.to(this.vid, {\n        duration: 0.1,\n        opacity: 0,\n      }); */\n      gsap.to(this.material.uniforms.distortion, {\n        duration: 2,\n        value: 2,\n        ease: \"power2.inOut\",\n      });\n\n      gsap.to(this.material.uniforms.progress, {\n        duration: 0.5,\n        value: 1,\n        delay: 1.5,\n      });\n      gsap.to(this.bloomPass, {\n        duration: 2,\n        strength: 6,\n        ease: \"power2.in\",\n      });\n\n      gsap.to(this.material.uniforms.distortion, {\n        duration: 2,\n        value: 0,\n        delay: 2,\n        ease: \"power2.inOut\",\n      });\n      gsap.to(this.bloomPass, {\n        duration: 2,\n        strength: 0,\n        delay: 2,\n        ease: \"power2.out\",\n        /*   onComplete: () => {\n          this.video.currentTime = 0;\n\n          this.video.play();\n          gsap.to(this.video, {\n            duration: 0.1,\n            opacity: 1,\n          });\n        }, */\n      });\n    });\n  }\n\n  settings() {\n    let that = this;\n    this.settings = {\n      progress: 0,\n      distortion: 0,\n    };\n  }\n\n  addPost() {\n    this.renderScene = new RenderPass(this.scene, this.camera);\n\n    this.bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(window.innerWidth, window.innerHeight),\n      1.5,\n      0.4,\n      0.85\n    );\n\n    this.bloomPass.threshold = this.state.data.bloomThreshold;\n    this.bloomPass.strength = this.state.data.bloomStrength;\n    this.bloomPass.radius = this.state.data.bloomRadius;\n\n    this.composer = new EffectComposer(this.renderer);\n    this.composer.addPass(this.renderScene);\n    this.composer.addPass(this.bloomPass);\n  }\n\n  addMesh() {\n    this.material = new THREE.ShaderMaterial({\n      fragmentShader: fragment,\n      vertexShader: vertex,\n      /*   extensions: {\n        derivatives: \"#extension GL_OES_standard_derivatives: enable\",\n      }, */\n      uniforms: {\n        time: { type: \"f\", value: 0 },\n\n        distortion: { type: \"f\", value: 0.0 },\n        t: { type: \"t\", value: new THREE.TextureLoader().load(t) },\n        t1: { type: \"t\", value: new THREE.TextureLoader().load(t1) },\n        resolution: { type: \"v4\", value: new THREE.Vector4() },\n        progress: { type: \"f\", value: 0 },\n        uvRate1: {\n          value: new THREE.Vector2(1, 1),\n        },\n      },\n      side: THREE.DoubleSide,\n    });\n\n    /*   this.geometry = new THREE.PlaneBufferGeometry(\n      480 * 1.75,\n      820 * 1.75,\n      480,\n      820\n    ); */\n\n    //1920 × 1272\n\n    this.geometry = new THREE.PlaneBufferGeometry(1920, 1280, 960, 640);\n\n    this.plane = new THREE.Points(this.geometry, this.material);\n    this.scene.add(this.plane);\n  }\n\n  stop = () => {\n    this.setState({\n      paused: true,\n    });\n  };\n\n  play = () => {\n    this.setState({\n      paused: false,\n    });\n  };\n\n  setupResize = () => {\n    this.mount.addEventListener(\"resize\", this.resize);\n  };\n\n  handleUpdate = (newData) =>\n    this.setState((prevState) => ({\n      data: { ...prevState.data, ...newData },\n    }));\n\n  resize() {\n    const width = this.mount.clientWidth;\n    const height = this.mount.clientHeight;\n\n    this.renderer.setSize(width, height);\n    this.camera.aspect = width / height;\n    this.composer.setSize(width, height);\n\n    this.camera.updateProjectionMatrix();\n  }\n\n  init() {\n    let _time = this.state.time;\n    _time += 0.05;\n    this.setState({\n      time: _time,\n    });\n\n    this.material.uniforms.time.value = this.state.time;\n    //this.material.uniforms.distortion.value = this.state.data.distortion;\n    //this.bloomPass.strength = this.state.data.bloomStrength;\n    this.requestID = requestAnimationFrame(this.init.bind(this));\n    //this.renderer.render(this.scene, this.camera);\n    this.composer.render();\n  }\n\n  componentWillUnmount() {\n    //this.mount.removeEventListener(\"resize\", this.resize);\n\n    this.stop();\n    //this.loader = null;\n    this.scene = null;\n    this.camera = null;\n    //this.controls.dispose();\n    cancelAnimationFrame(this.requestID);\n    this.mount.removeChild(this.renderer.domElement);\n  }\n\n  render() {\n    //const { data } = this.state;\n\n    return (\n      <>\n        {/*    <div className=\"video\">\n          <video\n            src={vid2}\n            autoPlay\n            muted\n            ref={(ref) => (this.vid = ref)}\n          ></video>\n        </div> */}\n        <div id=\"container\" ref={(ref) => (this.mount = ref)} />\n      </>\n    );\n  }\n}\n\nexport default Backdrop;\n","/Users/ishansengupta/Desktop/icosohedron/src/components/VisibilitySensor.js",[],{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","severity":1,"message":"40","line":21,"column":11,"nodeType":"41","endLine":21,"endColumn":47},{"ruleId":"35","replacedBy":"42"},{"ruleId":"37","replacedBy":"43"},{"ruleId":"44","severity":1,"message":"45","line":115,"column":9,"nodeType":"46","messageId":"47","endLine":115,"endColumn":13},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement",["48"],["49"],"no-unused-vars","'that' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]